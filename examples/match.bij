dec putIntLn :: Int -> Int
def putIntLn i = ccall<printf "%i\n" i>

dec putStrLn :: Str -> Int
def putStrLn s = ccall<printf "%s\n" s>

dec add :: Int -> Int -> Int
def add x y = prim<add x y>

dec sub :: Int -> Int -> Int
def sub x y = prim<sub x y>

dec mul :: Int -> Int -> Int
def mul x y = prim<mul x y>

dec div :: Int -> Int -> Int
def div x y = prim<div x y>

dec fac :: Int -> Int
def fac x = match x with
    case 0 of 1
    case y of mul x (fac (sub x 1))

gadt List =
    | Cons :: a -> List a -> List a
    | Nil :: List a

dec id :: a -> a
def id x = x

dec map :: (a -> b) -> List a -> List b
def map f ls = match ls with
    case Cons a as of Cons (f a) (map f as)
    case Nil of Nil

dec showList :: (a -> Int) -> List a -> Int
def showList showElem ls = let val x = map showElem ls in 0

entry start
dec start :: Int -> Int
def start x = let
val tmp = showList putStrLn (Cons "test" Nil)
in showList putIntLn (map (add 2) (Cons 1 (Cons 3 Nil)))